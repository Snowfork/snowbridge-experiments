/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface SubstrateLightClientInterface extends ethers.utils.Interface {
  functions: {
    "append(bytes32,bytes)": FunctionFragment;
    "getMerkleProof(bytes32,uint256)": FunctionFragment;
    "getPeaks(uint256)": FunctionFragment;
    "hashParent(uint256,bytes32,bytes32)": FunctionFragment;
    "inclusionProof(bytes32,uint256,uint256,bytes,bytes32[],bytes32[])": FunctionFragment;
    "isLeaf(uint256)": FunctionFragment;
    "mountainHeight(uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "append",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getMerkleProof",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPeaks",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "hashParent",
    values: [BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "inclusionProof",
    values: [
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike[],
      BytesLike[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isLeaf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mountainHeight",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "append", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMerkleProof",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getPeaks", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hashParent", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "inclusionProof",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isLeaf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "mountainHeight",
    data: BytesLike
  ): Result;

  events: {};
}

export class SubstrateLightClient extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: SubstrateLightClientInterface;

  functions: {
    append(
      root: BytesLike,
      data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "append(bytes32,bytes)"(
      root: BytesLike,
      data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    getMerkleProof(
      root: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string[], string[]] & {
        size: BigNumber;
        peakSet: string[];
        siblings: string[];
      }
    >;

    "getMerkleProof(bytes32,uint256)"(
      root: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string[], string[]] & {
        size: BigNumber;
        peakSet: string[];
        siblings: string[];
      }
    >;

    getPeaks(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { peaks: BigNumber[] }>;

    "getPeaks(uint256)"(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { peaks: BigNumber[] }>;

    hashParent(
      index: BigNumberish,
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    "hashParent(uint256,bytes32,bytes32)"(
      index: BigNumberish,
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    inclusionProof(
      root: BytesLike,
      size: BigNumberish,
      index: BigNumberish,
      value: BytesLike,
      peakSet: BytesLike[],
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    "inclusionProof(bytes32,uint256,uint256,bytes,bytes32[],bytes32[])"(
      root: BytesLike,
      size: BigNumberish,
      index: BigNumberish,
      value: BytesLike,
      peakSet: BytesLike[],
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isLeaf(index: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>;

    "isLeaf(uint256)"(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    mountainHeight(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number]>;

    "mountainHeight(uint256)"(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number]>;
  };

  append(
    root: BytesLike,
    data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "append(bytes32,bytes)"(
    root: BytesLike,
    data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  getMerkleProof(
    root: BytesLike,
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string[], string[]] & {
      size: BigNumber;
      peakSet: string[];
      siblings: string[];
    }
  >;

  "getMerkleProof(bytes32,uint256)"(
    root: BytesLike,
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string[], string[]] & {
      size: BigNumber;
      peakSet: string[];
      siblings: string[];
    }
  >;

  getPeaks(size: BigNumberish, overrides?: CallOverrides): Promise<BigNumber[]>;

  "getPeaks(uint256)"(
    size: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  hashParent(
    index: BigNumberish,
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  "hashParent(uint256,bytes32,bytes32)"(
    index: BigNumberish,
    left: BytesLike,
    right: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  inclusionProof(
    root: BytesLike,
    size: BigNumberish,
    index: BigNumberish,
    value: BytesLike,
    peakSet: BytesLike[],
    siblings: BytesLike[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  "inclusionProof(bytes32,uint256,uint256,bytes,bytes32[],bytes32[])"(
    root: BytesLike,
    size: BigNumberish,
    index: BigNumberish,
    value: BytesLike,
    peakSet: BytesLike[],
    siblings: BytesLike[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  isLeaf(index: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  "isLeaf(uint256)"(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  mountainHeight(
    size: BigNumberish,
    overrides?: CallOverrides
  ): Promise<number>;

  "mountainHeight(uint256)"(
    size: BigNumberish,
    overrides?: CallOverrides
  ): Promise<number>;

  callStatic: {
    append(
      root: BytesLike,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "append(bytes32,bytes)"(
      root: BytesLike,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    getMerkleProof(
      root: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string[], string[]] & {
        size: BigNumber;
        peakSet: string[];
        siblings: string[];
      }
    >;

    "getMerkleProof(bytes32,uint256)"(
      root: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string[], string[]] & {
        size: BigNumber;
        peakSet: string[];
        siblings: string[];
      }
    >;

    getPeaks(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    "getPeaks(uint256)"(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    hashParent(
      index: BigNumberish,
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    "hashParent(uint256,bytes32,bytes32)"(
      index: BigNumberish,
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    inclusionProof(
      root: BytesLike,
      size: BigNumberish,
      index: BigNumberish,
      value: BytesLike,
      peakSet: BytesLike[],
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    "inclusionProof(bytes32,uint256,uint256,bytes,bytes32[],bytes32[])"(
      root: BytesLike,
      size: BigNumberish,
      index: BigNumberish,
      value: BytesLike,
      peakSet: BytesLike[],
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    isLeaf(index: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

    "isLeaf(uint256)"(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    mountainHeight(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;

    "mountainHeight(uint256)"(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;
  };

  filters: {};

  estimateGas: {
    append(
      root: BytesLike,
      data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "append(bytes32,bytes)"(
      root: BytesLike,
      data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    getMerkleProof(
      root: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getMerkleProof(bytes32,uint256)"(
      root: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPeaks(size: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    "getPeaks(uint256)"(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashParent(
      index: BigNumberish,
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "hashParent(uint256,bytes32,bytes32)"(
      index: BigNumberish,
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    inclusionProof(
      root: BytesLike,
      size: BigNumberish,
      index: BigNumberish,
      value: BytesLike,
      peakSet: BytesLike[],
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "inclusionProof(bytes32,uint256,uint256,bytes,bytes32[],bytes32[])"(
      root: BytesLike,
      size: BigNumberish,
      index: BigNumberish,
      value: BytesLike,
      peakSet: BytesLike[],
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isLeaf(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    "isLeaf(uint256)"(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mountainHeight(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "mountainHeight(uint256)"(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    append(
      root: BytesLike,
      data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "append(bytes32,bytes)"(
      root: BytesLike,
      data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    getMerkleProof(
      root: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getMerkleProof(bytes32,uint256)"(
      root: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPeaks(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getPeaks(uint256)"(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashParent(
      index: BigNumberish,
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "hashParent(uint256,bytes32,bytes32)"(
      index: BigNumberish,
      left: BytesLike,
      right: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    inclusionProof(
      root: BytesLike,
      size: BigNumberish,
      index: BigNumberish,
      value: BytesLike,
      peakSet: BytesLike[],
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "inclusionProof(bytes32,uint256,uint256,bytes,bytes32[],bytes32[])"(
      root: BytesLike,
      size: BigNumberish,
      index: BigNumberish,
      value: BytesLike,
      peakSet: BytesLike[],
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isLeaf(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isLeaf(uint256)"(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    mountainHeight(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "mountainHeight(uint256)"(
      size: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
